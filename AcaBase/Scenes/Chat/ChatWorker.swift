//
//  ChatWorker.swift
//  AcaBase
//
//  Created by Seif eddinne meddeb on 2/28/21.
//  Copyright (c) 2021 Seif eddinne meddeb. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Firebase
import FirebaseDatabase

class ChatWorker
{
    
    var chatStore : ChatStoreProtocol?

    var ref: DatabaseReference
    
    init(chatStore: ChatStoreProtocol = ChatAPI()) {
        self.chatStore = chatStore
        ref = Database.database().reference()
    }
    
    func getMessages(for discussionId: Int, completionHandler: @escaping ([MessageDAO]?) -> Void)
    {
        ref.child("discussions/\(discussionId)").observe(.value, with: { (snapshot) in
            
            let postDict = snapshot.value as? [String : AnyObject] ?? [:]
            
            var list = [AnyObject]()
            for (key,object) in postDict {
                if key == "messages" {
                    if let arrayOfMsg = object as? [AnyObject] {
                            list = arrayOfMsg
                    } else {
                        if let msgDict = object as? [String : AnyObject] {
                            var arrayOfMsgs = [AnyObject]()
                            for (_,msgDictObject) in msgDict {
                                print("msgDictObject:\(msgDictObject)\n")
                                arrayOfMsgs.append(msgDictObject)
                            }
                            list = arrayOfMsgs
                        }
                    }
                }
                
            }
            
            if let data = try? JSONSerialization.data(withJSONObject: list) {
                do {
                    let jsonStr = String(data: data, encoding: .utf8)!.replacingOccurrences(of: "\\\"", with: "\"")
                    print("jsonStr:\(jsonStr)")
                    print("\\\"")
                    print("\"")
                    
                    var messages = try JSONDecoder().decode([MessageDAO].self, from: data)
                    
                    messages = messages.sorted{return $0.timestamp ?? 0 < $1.timestamp ?? 0}
                    
                    DispatchQueue.main.async {
                        completionHandler(messages)
                    }
                } catch {
                    print("error Decoding:\(error)")
                    DispatchQueue.main.async {
                        completionHandler(nil)
                    }
                }
            }
            
        }) { (error) in
            print("error:\(error.localizedDescription)")
            DispatchQueue.main.async {
                completionHandler(nil)
            }
        }
    }
    
    func sendMessage(for discussionId: Int?, tutorId: Int, message: String, messageId: Int) {
        let newMessage : [String : Any] = ["askId" : discussionId ?? 0,
                                           "body" : message,
                                           "from" : UserManager.shared.currentUser?.userId ?? 0,
                                           "seen" : false,
                                           "timestamp" : Int(NSDate().timeIntervalSince1970)*1000,
                                           "to" : tutorId]
        
        let _ = ref.child("discussions/\(discussionId ?? 0)/messages").child("\(messageId)").setValue(newMessage)
        ref.child("discussions/\(discussionId ?? 0)").updateChildValues(["lastMessage":message,"lastUpdate" : Int(NSDate().timeIntervalSince1970)*1000])
    }
    
    func sendAttachement(images: [UIImage], attachements: [Attachement], completionHandler:  @escaping (AttachementResponse?,Error?) -> ()) {
        self.chatStore?.sendAttachements(images: images, attachements: attachements) { (response: () throws -> AttachementResponse) in
            do {
                let attachementResponse = try response()
                DispatchQueue.main.async {
                    completionHandler(attachementResponse,nil)
                }
            } catch {
                DispatchQueue.main.async {
                    completionHandler(nil,error)
                }
            }
        }
    }
    
    func sendAttachementMessage(for discussionId: Int?, tutorId: Int, message: String, messageId: Int, sentAttachements: [Attachement], attachement: AttachementResponse) {

        var discussionId = discussionId ?? 0
        if let files = attachement.files {
            for file in files.enumerated() {
                let sentFile = sentAttachements.filter{return String(file.element.fileName.prefix(23)) == String($0.name?.prefix(23) ?? "")}.first
                discussionId += file.offset
                let newMessage : [String : Any] = ["askId" : discussionId,
                                                   "from" : UserManager.shared.currentUser?.userId ?? 0,
                                                   "seen" : false,
                                                   "timestamp" : Int(NSDate().timeIntervalSince1970)*1000,
                                                   "to" : tutorId,
                                                   "attachement" : ["extension":file.element.mimeType,
                                                                    "link":file.element.url,
                                                                    "name":file.element.fileName,
                                                                    "size":file.element.fileSize,
                                                                    "duration":sentFile?.duration ?? 0.0]
                                                    ]
                let _ = ref.child("discussions/\(discussionId)/messages").child("\(messageId)").setValue(newMessage)
                ref.child("discussions/\(discussionId)").updateChildValues(["lastMessage":file.element.fileName])
            }
        }
    }
}

protocol ChatStoreProtocol {
    func sendAttachements(images: [UIImage], attachements: [Attachement], completionHandler:  @escaping (() throws -> AttachementResponse) -> Void)
    func submitChatRating(request: RateTutorRequest, completionHandler: @escaping (() throws -> ()) -> Void)
}
