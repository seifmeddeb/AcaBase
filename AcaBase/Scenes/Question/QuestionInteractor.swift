//
//  QuestionInteractor.swift
//  AcaBase
//
//  Created by Seif eddinne meddeb on 10/28/20.
//  Copyright (c) 2020 Seif eddinne meddeb. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol QuestionBusinessLogic
{
    func getQuestionData(request: Question.ViewData.Request)
    func getFileData(request: Question.FileData.Request)
    func getPrefilledQuestion(request: Question.FromQuiz.Request)
    func askQuestion(request: Question.Ask.Request)
}

protocol QuestionDataStore
{
    // going into the view
    var tutors: [TutorDAO]? { get set }
    var topics: [TopicDAO]? { get set }
    var tutor: TutorDAO? { get set }
    var question : QuestionDAO? { get set }
    var subject : SubjectDAO? { get set }
}

class QuestionInteractor: QuestionBusinessLogic, QuestionDataStore
{
    var presenter: QuestionPresentationLogic?
    var worker: QuestionWorker?
    var tutorWorker: TutorListWorker?
    var tutors: [TutorDAO]?
    var topics: [TopicDAO]?
    // selected tutor
    var tutor: TutorDAO?
    // when comming from a quiz pass the question data
    var question: QuestionDAO?
    var subject: SubjectDAO?
    
    // MARK: getQuestionData
    func getQuestionData(request: Question.ViewData.Request)
    {
        tutorWorker = TutorListWorker()
        var subjectList = [SubjectDAO]()
        var disableTutorSelection = false
        if let topicList = self.topics {
            subjectList = tutorWorker?.getSubjectsFromTopicList(topicList: topicList) ?? [SubjectDAO]()
        }
        if let tutor = self.tutor {
            subjectList = tutor.subjects ?? [SubjectDAO]()
            disableTutorSelection = true
        }
        
        
        if subjectList.count > 0 {
            let response = Question.ViewData.Response(tutor: self.tutor, subjectList: subjectList, disableTutorSelection: disableTutorSelection)
            presenter?.presentQuestionData(response: response)
        } else {
            let homeWorker = HomeWorker(mainPageStore: MainPageAPI())
            homeWorker.getTopics(completionHandler: { (topics) in
                if let topicList = topics {
                    self.topics = topicList
                    subjectList = self.tutorWorker?.getSubjectsFromTopicList(topicList: topicList) ?? [SubjectDAO]()
                    if let tutor = self.tutor {
                        subjectList = tutor.subjects ?? [SubjectDAO]()
                        disableTutorSelection = true
                    }
                    let response = Question.ViewData.Response(tutor: self.tutor, subjectList: subjectList, disableTutorSelection: disableTutorSelection)
                    self.presenter?.presentQuestionData(response: response)
                }
            })
        }
        
        // getTutors for DataStore
        if self.tutors == nil {
            let homeWorker = HomeWorker(mainPageStore: MainPageAPI())
            homeWorker.getTutors { (tutors) in
                self.tutors = tutors
            }
        }
        
    }
    
    // MARK: getFileData
    func getFileData(request: Question.FileData.Request) {
        let url = request.url
        let attachement = Attachement(name: url.lastPathComponent, url: url, size: getFileSize(url: url), isAudio: false)
        let response = Question.FileData.Response(attachement: attachement)
        presenter?.presentChosenFile(response: response)
    }
    
    // MARK: getPrefilledQuestion
    func getPrefilledQuestion(request: Question.FromQuiz.Request) {
        
        self.worker = QuestionWorker()
        tutorWorker = TutorListWorker()
        
        if let question = self.question {
            if let topics = self.topics {
                var subjectList = self.tutorWorker?.getSubjectsFromTopicList(topicList: topics) ?? [SubjectDAO]()
                if let subject = self.worker!.getSubject(for: question, from: topics) {
                    subjectList = subjectList.filter({ $0.objectId == subject.objectId})
                    self.topics = topics.filter({ $0.objectId == subject.objectId})
                    let response = Question.FromQuiz.Response(question: question, subject: subject, subjectList: subjectList)
                    presenter?.presentPrefilledQuestion(response: response)
                }
            }
        }
    }
    
    // MARK: Ask Question
    func askQuestion(request: Question.Ask.Request) {
        self.worker = QuestionWorker(askStore: AskAPI())
        let request = AskRequest(title: request.title, subject: request.subjectId, trainerId: request.tutorId, description: request.description)
        
        self.worker?.askQuestion(request: request, completionHandler: { (questionId, error) in
            if let error = error {
                let response = Question.Ask.Response(questionId: questionId, error: error)
                self.presenter?.presentAskQuestionError(response: response)
            } else {
                let response = Question.Ask.Response(questionId: questionId, error: error)
                self.presenter?.presentAskQuestion(response: response)
            }
        })
    }
}
