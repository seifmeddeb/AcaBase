//
//  QuestionViewController.swift
//  AcaBase
//
//  Created by Seif eddinne meddeb on 10/28/20.
//  Copyright (c) 2020 Seif eddinne meddeb. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import AVFoundation
import MobileCoreServices

protocol QuestionDisplayLogic: class
{
    func displayQuestionData(viewModel: Question.ViewData.ViewModel)
    func displayChosenFile(viewModel: Question.FileData.ViewModel)
    func displayChosenFileError(viewModel: Question.FileData.ViewModel)
    func displayPrefilledQuestion(viewModel: Question.FromQuiz.ViewModel)
}

class QuestionViewController: UIViewController, QuestionDisplayLogic
{
    var interactor: QuestionBusinessLogic?
    var router: (NSObjectProtocol & QuestionRoutingLogic & QuestionDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = QuestionInteractor()
        let presenter = QuestionPresenter()
        let router = QuestionRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        getQuestionData()
        setPickerViewWithToolBar()
        hideKeyboardWhenTappedAround()
        addToolBarToTextViewKeyboard()
        self.title = "Poser une question"
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.navigationController?.navigationBar.isHidden = false
        setNormalNavBarWhenAppearing()
        registerForKeyboardNotifications()
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        deregisterFromKeyboardNotifications()
        self.tutor = nil
    }
    
    override func viewDidAppear(_ animated: Bool) {
        if let tutor = self.tutor {
            self.updateTutorView(with: tutor)
        }
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return .darkContent
    }
    
    // MARK: Outlets
    
    @IBOutlet weak var subjectTextField: UITextField!
    @IBOutlet weak var imagesCollectionView: UICollectionView!
    @IBOutlet weak var scrollView: UIScrollView!
    @IBOutlet weak var descTextView: UITextView!
    @IBOutlet weak var textViewParent: UIView!
    
    // tutor details outlets
    @IBOutlet weak var tutorView: UIView!
    @IBOutlet weak var fullName: UILabel!
    @IBOutlet weak var AnswersLbl: UILabel!
    @IBOutlet weak var subjectsLbl: UILabel!
    @IBOutlet weak var ratingView: RatingView!
    @IBOutlet weak var tutorImageView: UIImageView!
    @IBOutlet weak var noTutorView: UIView!
    @IBOutlet weak var selctTutorBtn: UIButton!
    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var titleTextField: UITextField!
    
    @IBOutlet weak var titleBorderView: UIView!
    @IBOutlet weak var subjectBorderView: UIView!
    @IBOutlet weak var descBorderView: UIView!
    
    // MARK: Properties
    let subjectPickerView = UIPickerView()
    var subjects = [SubjectDAO]()
    var images = [UIImage]()
    var tutor : TutorViewModel?
    var attachementsList = [Attachement]()
    var player: AVAudioPlayer?
    var trackPlayedCell : RecordingCell?
    var currentURL :URL?
    var isPrefilledSubject = false
    // **********************************
    // MARK: VIP Calls
    // **********************************
    
    // MARK: getQuestionData
    func getQuestionData()
    {
        let request = Question.ViewData.Request()
        interactor?.getQuestionData(request: request)
    }
    
    func displayQuestionData(viewModel: Question.ViewData.ViewModel)
    {
        if !self.isPrefilledSubject {
            self.subjects = viewModel.subjectList
        }
        selctTutorBtn.isEnabled = !viewModel.disableTutorSelection
        getPrefilledQuestion()
        if let tutor = viewModel.tutor {
            self.tutor = tutor
            if let subjects = tutor.model.subjects, !self.isPrefilledSubject {
                self.subjects = subjects
            }
            self.updateTutorView(with: tutor)
        }
    }
    
    // MARK: getFileData
    func addChosenFile(url: URL)
    {
        let request = Question.FileData.Request(url: url)
        interactor?.getFileData(request: request)
    }
    
    func displayChosenFile(viewModel: Question.FileData.ViewModel)
    {
        if let fileAttached = viewModel.attachement {
            self.attachementsList.append(fileAttached)
            self.tableView.reloadData()
        }
    }
    
    func displayChosenFileError(viewModel: Question.FileData.ViewModel) {
        let alert = UIAlertController(title: "", message: "Fichier ne peut pas être ajouter, notre équipe ont été informer de ce proplème", preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "Cancel", style: .destructive))
        self.present(alert,animated: true)
    }
    
    // MARK: getPrefilledQuestion
    func getPrefilledQuestion() {
        let request = Question.FromQuiz.Request()
        interactor?.getPrefilledQuestion(request: request)
    }
    
    func displayPrefilledQuestion(viewModel: Question.FromQuiz.ViewModel) {
        self.subjects = viewModel.subjectList
        subjectTextField.text = viewModel.subject
        titleTextField.text = viewModel.title
        descTextView.text = viewModel.desc
        isPrefilledSubject = true
    }
    
    // **********************************
    // MARK: IBActions
    // **********************************
    
    @IBAction func filesPressed(_ sender: Any) {
        let importMenu = UIDocumentPickerViewController(documentTypes: ["public.item"], in: .import)
        importMenu.delegate = self
        importMenu.modalPresentationStyle = .fullScreen
        self.present(importMenu, animated: true, completion: nil)
    }
    
    @IBAction func askQuestionPressed(_ sender: Any) {
        
        var color = titleTextField.text?.count == 0 ? UIColor.red : primaryGreen
        titleBorderView.borderColor = color
        color = subjectTextField.text?.count == 0 ? UIColor.red : primaryGreen
        subjectBorderView.borderColor = color
        color = descTextView.text?.count == 0 ? UIColor.red : primaryGreen
        descBorderView.borderColor = color
        
    }
    
    // **********************************
    // MARK: Private functions
    // **********************************
    
    private func updateTutorView(with viewModel: TutorViewModel){
        self.tutorView.isHidden = false
        self.noTutorView.isHidden = true
        self.fullName.text = viewModel.model.fullName
        let answeredQuestion = "Answers: \(viewModel.model.answredQuestions)"
        self.AnswersLbl.text = answeredQuestion
        self.subjectsLbl.text = viewModel.subjects
        self.ratingView.setRating(rating: viewModel.model.rate)
        self.tutorImageView.setImageAsync(url: viewModel.imageUrl)
    }
    
    private func setPickerViewWithToolBar() {
        
        subjectTextField.inputView = subjectPickerView
        subjectPickerView.delegate = self
        
        subjectPickerView.backgroundColor = .white
        
        let toolBar = UIToolbar()
        toolBar.barStyle = UIBarStyle.default
        toolBar.isTranslucent = true
        toolBar.tintColor = primaryGreen
        toolBar.sizeToFit()
        
        let doneButton = UIBarButtonItem(title: "Terminé", style: UIBarButtonItem.Style.done, target: self, action: #selector(self.donePicker))
        let spaceButton = UIBarButtonItem(barButtonSystemItem: UIBarButtonItem.SystemItem.flexibleSpace, target: nil, action: nil)
        let cancelButton = UIBarButtonItem(title: "Annulé", style: UIBarButtonItem.Style.plain, target: self, action: #selector(self.cancelPicker))
        
        toolBar.setItems([cancelButton, spaceButton, doneButton], animated: false)
        toolBar.isUserInteractionEnabled = true
        
        subjectTextField.inputAccessoryView = toolBar
    }
    
    @objc private func donePicker() {
        let row = self.subjectPickerView.selectedRow(inComponent: 0)
        self.subjectPickerView.selectRow(row, inComponent: 0, animated: false)
        self.subjectTextField.text = self.subjects[row].name
        self.subjectTextField.resignFirstResponder()
    }
    @objc private func cancelPicker() {
        self.subjectTextField.text = nil
        self.subjectTextField.resignFirstResponder()
    }
    
    private func addToolBarToTextViewKeyboard() {
        let toolBar = UIToolbar()
        toolBar.barStyle = UIBarStyle.default
        toolBar.isTranslucent = true
        toolBar.tintColor = primaryGreen
        toolBar.sizeToFit()
        
        let doneButton = UIBarButtonItem(title: "Terminé", style: UIBarButtonItem.Style.done, target: self, action: #selector(self.doneTextView))
        let spaceButton = UIBarButtonItem(barButtonSystemItem: UIBarButtonItem.SystemItem.flexibleSpace, target: nil, action: nil)
        let cancelButton = UIBarButtonItem(title: "Annulé", style: UIBarButtonItem.Style.plain, target: self, action: #selector(self.cancelTextView))
        
        toolBar.setItems([cancelButton, spaceButton, doneButton], animated: false)
        toolBar.isUserInteractionEnabled = true
        
        descTextView.inputAccessoryView = toolBar
    }
    @objc private func doneTextView() {
        self.descTextView.resignFirstResponder()
    }
    @objc private func cancelTextView() {
        self.descTextView.text = nil
        self.descTextView.resignFirstResponder()
    }
    
    private func playSound(url: URL) {
        if let player = player{
            player.stop()
            self.player = nil
        }
        if currentURL != url {
            currentURL = url
            do {
                try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
                try AVAudioSession.sharedInstance().setActive(true)
                
                /* The following line is required for the player to work on iOS 11. Change the file type accordingly*/
                player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileType.m4a.rawValue)
                player?.delegate = self
                /* iOS 10 and earlier require the following line:
                 player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileTypeMPEGLayer3) */
                
                guard let player = player else { return }
                
                player.play()
                
            } catch let error {
                print(error.localizedDescription)
            }
        } else {
            self.currentURL = nil
        }
    }
    
    private func deleteAttachedItem(_ attachement: Attachement, _ row: Int){
        if attachement.url == self.trackPlayedCell?.attachement?.url && ((self.player?.isPlaying) != nil) {
            self.player?.stop()
            self.player = nil
        }
        
        if !attachement.isAudio && ((self.player?.isPlaying) != nil) {
            self.player?.stop()
            self.player = nil
        }
        
        self.attachementsList.remove(at: row)
        self.tableView.reloadData()
    }
}
extension QuestionViewController : UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return attachementsList.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let attachement = attachementsList[indexPath.row]
        if attachement.isAudio {
            let cell = tableView.dequeueReusableCell(withIdentifier: "RecordingCell", for: indexPath) as! RecordingCell
            cell.set(viewModel: attachement)
            cell.didPressPlay {
                if let lastCell = self.trackPlayedCell, lastCell != cell {
                    lastCell.setPlayImage()
                }
                self.trackPlayedCell = cell
                self.playSound(url: attachement.url!)
            }
            cell.didPressDelete {
                self.deleteAttachedItem(attachement, indexPath.row)
            }
            return cell
        } else {
            let cell = tableView.dequeueReusableCell(withIdentifier: "AttachementCell", for: indexPath) as! AttachementCell
            cell.set(viewModel: attachement)
            cell.didPressDelete {
                self.deleteAttachedItem(attachement, indexPath.row)
            }
            return cell
        }
        
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return UITableView.automaticDimension
    }
}
extension QuestionViewController : UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return images.count + 1
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if indexPath.row == 0 {
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "SelectionCell", for: indexPath)
            return cell
        } else {
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "ImageCell", for: indexPath) as! ImageCell
            cell.set(image: images[indexPath.row-1])
            cell.didPressDelete {
                self.images.remove(at: indexPath.row-1)
                collectionView.reloadData()
            }
            return cell
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize
    {
        let dimension = imagesCollectionView.frame.height - 2.0
        return CGSize(width: dimension, height: dimension)
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        // FIXME: add click event handler
        if indexPath.row == 0 {
            ImagePickerManager().pickImage(self){ image in
                self.images.append(image)
                collectionView.reloadData()
                collectionView.scrollToItem(at: IndexPath(row: self.images.count, section: 0), at: .right, animated: true)
            }
        }
    }
}
extension QuestionViewController : UIPickerViewDelegate, UIPickerViewDataSource {
    func numberOfComponents(in pickerView: UIPickerView) -> Int {
        return 1
    }
    
    func pickerView( _ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {
        return subjects.count
    }
    
    func pickerView( _ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String? {
        return subjects[row].name
    }
    
    func pickerView( _ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
        subjectTextField.text = subjects[row].name
    }
}
extension QuestionViewController : UITextFieldDelegate {
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return true
    }
}
extension QuestionViewController : UITextViewDelegate {
    
    func registerForKeyboardNotifications(){
        //Adding notifies on keyboard appearing
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWasShown(notification:)), name: UIResponder.keyboardWillShowNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillBeHidden(notification:)), name: UIResponder.keyboardWillHideNotification, object: nil)
    }
    
    func deregisterFromKeyboardNotifications(){
        //Removing notifies on keyboard appearing
        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillShowNotification, object: nil)
        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillHideNotification, object: nil)
    }
    
    @objc func keyboardWasShown(notification: NSNotification){
        //Need to calculate keyboard exact size due to Apple suggestions
        self.scrollView.isScrollEnabled = true
        let info = notification.userInfo!
        let keyboardSize = (info[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue.size
        let contentInsets : UIEdgeInsets = UIEdgeInsets(top: 0.0, left: 0.0, bottom: keyboardSize!.height, right: 0.0)
        
        self.scrollView.contentInset = contentInsets
        self.scrollView.scrollIndicatorInsets = contentInsets
        
        var aRect : CGRect = self.view.frame
        aRect.size.height -= (keyboardSize!.height + 40)
        if let activeTextView = self.textViewParent {
            if (!aRect.contains(activeTextView.frame.origin)){
                self.scrollView.scrollRectToVisible(activeTextView.frame, animated: true)
            }
        }
    }
    
    @objc func keyboardWillBeHidden(notification: NSNotification){
        //Once keyboard disappears, restore original positions
        self.scrollView.contentInset = UIEdgeInsets.zero
        self.scrollView.scrollIndicatorInsets = UIEdgeInsets.zero
        self.view.endEditing(true)
    }
}
extension QuestionViewController : AVAudioPlayerDelegate {
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        if let lastCell = self.trackPlayedCell {
            lastCell.setPlayImage()
            self.currentURL = nil
        }
    }
}
extension QuestionViewController : UIDocumentPickerDelegate {
    func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
        if controller.documentPickerMode == UIDocumentPickerMode.import {
            if let url = urls.first {
                addChosenFile(url: url)
            }
        }
    }
}
