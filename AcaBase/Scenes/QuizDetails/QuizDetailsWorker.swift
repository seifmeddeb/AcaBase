//
//  QuizDetailsWorker.swift
//  AcaBase
//
//  Created by Seif eddinne meddeb on 12/27/20.
//  Copyright (c) 2020 Seif eddinne meddeb. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class QuizDetailsWorker
{
    
    var quizStore : QuizStoreProtocol
    
    init(quizStore: QuizStoreProtocol = QuizAPI())
    {
        self.quizStore = quizStore
    }
    
    func fetchQuestions(for quiz: QuizDAO) -> [QuestionDAO]
    {
        return quiz.questions ?? [QuestionDAO]()
    }
    
    func updateQuestion(option: OptionDAO, question: QuestionDAO, questionList: [QuestionDAO],_ displayAnswer: inout Bool,_ displayWrong: inout Bool) -> [QuestionDAO] {
        
        var updatedQuestionsList = questionList
        var updatedQuestion = question
        
        updateOption(question, option, &updatedQuestion)
        
        updatedQuestion.state = getQuestionState(updatedQuestion, &displayAnswer, &displayWrong)

        updateQuestionInList(questionList, question, &updatedQuestionsList, updatedQuestion)
        
        return updatedQuestionsList
    }
    
    func getScore(for questions: [QuestionDAO]) -> Int {
        var correctAnswers = 0
        for question in questions {
            if question.state == .Correct {
                correctAnswers += 1
            }
        }
        
        return correctAnswers
    }
    
    // MARK: Private Funcs
    
    fileprivate func updateOption(_ question: QuestionDAO, _ option: OptionDAO, _ updatedQuestion: inout QuestionDAO) {
        
        for optionItem in question.options!.enumerated() {
            if optionItem.element == option {
                if optionItem.element.isTrue {
                    updatedQuestion.options![optionItem.offset].state = .Correct
                } else {
                    updatedQuestion.options![optionItem.offset].state = .Wrong
                }
            }
            
        }
        
        var wrongOptionNbr = 0
        for optionItem in updatedQuestion.options! {
            if optionItem.state == .Wrong {
                wrongOptionNbr = wrongOptionNbr + 1
            }
        }
        
        // If two answers wrong display the correct answer
        if wrongOptionNbr > 1 {
            for optionItem in question.options!.enumerated() {
                if optionItem.element.isTrue {
                    updatedQuestion.options![optionItem.offset].state = .Correct
                }
            }
        }
        
    }
    
    fileprivate func getQuestionState(_ updatedQuestion: QuestionDAO,_ displayAnswer: inout Bool,_ displayWrong: inout Bool) -> QuestionState {
        var wrongOptionNbr = 0
        var hasCorrect = false
        
        for optionItem in updatedQuestion.options!.enumerated() {
            if optionItem.element.state == .Correct {
                displayAnswer = true
                hasCorrect = true
            }
            if optionItem.element.state == .Wrong {
                wrongOptionNbr = wrongOptionNbr + 1
            }
        }
        
        if wrongOptionNbr == 1 && !hasCorrect {
            displayWrong = true
        }
        
        if wrongOptionNbr > 1 {
            displayAnswer = true
            return .Wrong
        }
        
        if hasCorrect {
            return .Correct
        }
        
        return .Undefined
    }
    
    fileprivate func updateQuestionInList(_ questionList: [QuestionDAO], _ question: QuestionDAO, _ updatedQuestionsList: inout [QuestionDAO], _ updatedQuestion: QuestionDAO) {
        for questionItem in questionList.enumerated() {
            if questionItem.element == question {
                updatedQuestionsList[questionItem.offset] = updatedQuestion
            }
        }
    }
    
    func saveScore(quizScore: ScoreRequest, completionHandler: @escaping (Bool) -> Void) {
        self.quizStore.saveScore(quizScore: quizScore) { (response: () throws -> Void) in
            do {
                let _ = try response()
                DispatchQueue.main.async {
                    completionHandler(true)
                }
            } catch {
                let nserror = error as NSError
                print("Unresolved error \(nserror), \(nserror.userInfo)")
                DispatchQueue.main.async {
                    completionHandler(false)
                }
            }
        }
    }
    
}
protocol QuizStoreProtocol {
    
    func saveScore(quizScore: ScoreRequest, completionHandler: @escaping (() throws -> Void) -> Void)
    
}
